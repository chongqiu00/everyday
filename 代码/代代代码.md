# 👣这是呵呵好吧吃不好的

---

## <一> 基本呀，别忘了

#### 1.5.3  应用

### 1.6 全局变量，局部变量

#### 1.6.0 应用

#####  1.6.1产生随机数

```c
#include <stdio.h>
#include <time.h>
unsigned int rand(void);
void srand(unsigned int seed);

//全局变量next
static unsigned int next;

int main(void)
{

	int count;
	unsigned int seed;
	int strat;
	
	printf_s("请按下任意数字开启程序（按下非数字按键即结束程序）：\n");

	while (scanf_s("%d", &strat) == 1)
	{
		srand(time(0));
		printf_s("next = %d \n", next);
		for (count = 0; count < 5; count++)
		{
			printf_s("%d\n", rand());
		}
		printf_s("请按下任意数字开启程序（按下非数字按键即结束程序）：\n");
	}
	printf_s("程序退出！\n");
	return 0;
}
void srand(unsigned int seed)//更换一个种子
{
	extern next;
	next = seed;
}
unsigned int rand(void)//产生一个随机数
{
	extern next;
	next = next * 1129847695 + 12345;
	return (next / 65536) % 32768;
}



```



##### 1.6.2 扔色子

```c
/*
* 时间：2020/10/23 23:17
* 功能：投掷骰子，用户输入骰子的面数，和需要投掷几次，程序需要反馈给用户每次投掷的结果与投掷骰子结束后，结果的总和
*/

#include <stdio.h>
#include <time.h>
int get_sides(void);
int get_dice(void);
int rand(void);
void srand(unsigned int seed);
unsigned int next;
int main(void)
{
	int dice;//次数
	int sides;
	int i;
	int count;//每次的结果
	int sum = 0;//共计
	printf("请输入任意键进入投掷骰子的小游戏中......\n若要退出请按#号键哦！\n");
	while (getchar() != '#')
	{
		printf("您已经进入到扔掷骰子小游戏中啦......\a\n");
		printf("你投掷的骰子有几面呢？\n");
		sides = get_sides();
		printf("你需要投掷骰子几次呢？\n");
		dice = get_dice();
		srand(time(0));
		for (i = 0; i < dice; i++)
		{
			
			count = rand();
			printf("第%d次投掷骰子的结果为：%d\n", i + 1, count);
			sum += count;
		}

		printf("本次投掷结束！投掷的总和为%d\n", sum);
		while (getchar() != '\n')
		{
			continue;
		}
		printf("请输入任意键进入投掷骰子的小游戏中......\n若要退出请按#号键哦！\n");
	}

	printf("您成功退出了扔掷骰子的小游戏哦，拜拜！\a\n");
	
	return 0;
}

int get_sides(void)
{
	int sides;
	char ch;
	while (scanf("%d", &sides) != 1 || sides <= 2)
	{
		printf("您输入的面数是不合现实的！\n亲！\n再输入一次吧！\n");
		while (ch = getchar() != '\n')
		{
			putchar(ch);
			printf("\n以上是非法输入哦！\n");
			continue;
		}
		
	}
	printf("面数输入成功！\n");
	return sides;
}
int get_dice(void)
{
	int dice;
	char ch;
	while (scanf("%d", &dice) != 1 || dice < 0)
	{
		printf("您输入的投掷次数不合现实哦！\n请重新输入吧！\n");
		while (ch = getchar() != '\n')
		{
			putchar(ch);
			printf("\n以上是非法输入哦！\n");
			continue;
		}

	}
	printf("输入投掷次数成功！\n");
	return dice;
}
int rand(void)//产生一个0——6的随机数
{
	next = next * 948674586 + 12345;
	return (next / 65536) % 6;
}

void srand(unsigned int seed)
{
	next = seed;
}


/*
* 运行结果：
* ---------------------------------------------------------------
* 请输入任意键进入投掷骰子的小游戏中......
若要退出请按#号键哦！
4
您已经进入到扔掷骰子小游戏中啦......
你投掷的骰子有几面呢？
3
面数输入成功！
你需要投掷骰子几次呢？
6
输入投掷次数成功！
第1次投掷骰子的结果为：3
第2次投掷骰子的结果为：2
第3次投掷骰子的结果为：4
第4次投掷骰子的结果为：3
第5次投掷骰子的结果为：1
第6次投掷骰子的结果为：0
本次投掷结束！投掷的总和为13
请输入任意键进入投掷骰子的小游戏中......
若要退出请按#号键哦！
#
您成功退出了扔掷骰子的小游戏哦，拜拜！
-------------------------------------------------------------------------
总结：
1，
分模块的思想很重要，尽量的划分细小的模块，是程序更加容易维护，修改
2，
这里面的next是一个静态的全局变量，系统默认它为文件作用域，静态变量，初始值为0
3，
rand() 和 srand()， 前者产生随机数，后者产生种子，将两者分开的原因是，便于使用time(0)来产生种子

*/

```





### 1.7 文件的打开/创建，关闭，读取写入

#### 1.7.1 open（）

- 头文件：

  > \#include <sys/types.h>
  >
  > \#include <sys/stat.h>
  >
  > \#include <fcntl.h>

- 函数原型：int open(const char *pathname, int flags);

- 返回值： 

  >  成功 -> 返回新文件描述符
  >
  >  失败 -> 返回-1

- 形参：

  > const char *pathname:文件的路径和文件名字
  >
  >  int flags:文件打开方式标志位
  >
  >  							必须三选一： O_RDONLY //只读
  >
  > ​             											O_WRONLY //只写
  >
  > ​              											O_RDWR  //可读可写

​      还可以加附加的文件打开方式标志位：。。。。。

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main (void)
{
  
  return 0;
}
```



#### 1.7.2  close();

- 头文件：

  > #include <unistd.h>

- 函数原型：

  > int close(int fd);

- 返回值：

  > 成功 :0
  >
  >  失败 : -1

- 形参

  > int fd 一个已经打开的文件描述符



#### 1.7.3 open()和close()示例



>
>
>```c
>#include <stdio.h>
>#include <sys/types.h>
>#include <sys/stat.h>
>#include <fcntl.h>
>#include <unistd.h>
>int main(void)
>{
>    int fd = open("1.txt",O_RDWR);
>    if (-1 == fd) perror("file open error");
>    else perror("file open ok");
>    //int fd = open("1.txt",O_RANDOM | O_CREAT);
>    char buff[12] = "";
>    int wret = write(fd,buff,12);
>   if (-1 = wret)perror("file write error");
>   else perror("file write ok");
>   int ret = close(fd);
>    if(-1 == ret) perror("file clse error");
>    else if(0 == ret) perror("file close ok");
>    }
>/*
>运行结果：
>成功：
>file open ok: Invalid argument
>file close ok: Invalid argument
>失败：
>file open error: No such file or directory
>file clse error: Bad file descriptor
>*/
>
>```
>
>

#### 1.7.4 writ()

- 头文件：

  >  #include <unistd.h>

- 函数原型：

  > size_t write(int fd, const void* buf, size_t count);

- 返回值：经过宏定义的一个整数

  > 成功：实际写入的字节数
  >
  > 失败：-1

- 形参：

  > int fd:一个已经打开了的文件描述符
  >
  > const void* buf:
  >
  > ​								void* buf:指针，通配型指针，可以指向任意类型的指针。表示指向要写入文件的内容。
  >
  > ​								size_t count:要写入的字节数

注意：

（1）写入的文件，将原有的文件覆盖，而不是在原文件之前插入写入。

（2）注意写入文件的字节数是你需要写入的字符长度，不要考虑结束标志'\0'，

==**文件是不存在结束符的！！！**==



#### 1.7.5 read()

- 头文件：

  >  #include <unistd.h>

- 函数原型：

  > size_t read(int fd, const void* buf, size_t count);

- 返回值：经过宏定义的一个整数

  > 成功：（1）实际读入的字节数
  >
  > ​			（2）当读到文件末尾时，返回1
  >
  > 失败：-1

- 形参：

  > int fd:一个已经打开了的文件描述符
  >
  > const void* buf:
  >
  > ​								void* buf:指针，通配型指针，可以指向任意类型的指针。表示指向要读入文件的内容。
  >
  > ​								size_t count:要写入的字节数



#### 1.7.5 read() 和 writ()示例

#### 1.7.6  文件IO总结

- 当read()读取目标字节大小大于真实函数读取的大小，read读取的字节数为真实函数读取的大小。
- 当write（）写入的目标字节大小真实函数读取的大小,write读取的字节数为目标字节大小。



#### 1.7.7 文件IO示例

复制1.txt的内容到2.txt中

> ```c
> #include <stdio.h>
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <fcntl.h>
> #include <unistd.h>
> int main(void)
> {
>     int wret;
>     int rret = 9;
>     int fd1 = open("1.txt",O_RDWR);
>     if (-1 == fd1) perror("file1 open error");
>     else perror("file1 open ok");
>     char buff[26] = "zww can study C very good!";
>      int fd2 = open("2.txt",O_RDWR);
>     if (-1 == fd2) perror("file2 open error");
>     else perror("file2 open ok");
>     //读
>     char num[2];
>     while(rret != 0)
>     {
>          rret = read(fd1,num,2);
>         if (-1 == rret) perror("file1 read 1 error");
>         else 
>         {
>              perror("file1 reed 1 ok");
>              //写
>              wret = write(fd2,num,1);
>           if (-1 == wret)perror("file2 write error");
>         else perror("file2 write ok");
>         }
>    }
> 
>  //关闭文件
>     int cret = close(fd1);
>     if(-1 == cret) perror("file1 clse error");
>     else if(0 == cret) perror("file1 close ok");
>       cret = close(fd2);
>     if(-1 == cret) perror("file2 clse error");
>     else if(0 == cret) perror("file2 close ok");
> }
> ```
>
> 



## <二>	运用吧

### 2.0🔴指针

#### 2.0.1  改变常量的内存单元地址

```c
#include <stdio.h>
void fun(int**);
int main(void)
{
	int i;
	int* p;
	//p = &i;
	printf_s("%p\n", p);
	//fun(&p);
	fun(&i);
	printf_s("%p\n", p);
	return 0;
}
void fun(int** q)//传入地址的地址，变量的地址是你要当成变量所要更改的内容
{
	*q = (int*)0xffffffff;
	return;
}
```

#### 2.0.2 动态内存跨函数分配

在子函数中动态分配数组空间，不会将子函数中的数组释放。

```c
#include <stdio.h>
#include <malloc.h>
int* MallocAddress(void);
int main(void)
{
	int* a;
	a = MallocAddress();
	printf_s("%d, %d, %d, %d",a[0],a[1],a[2],a[3]);
	free(a);
	a = NULL;
	return 0;
}

int* MallocAddress(void)//P数组空间不会被释放
{
	int* p = (int*)malloc(sizeof(int) * 4);
	p[0] = 1;
	p[1] = 2;
	p[2] = 3;
	p[3] = 4;

	return p;
 }
```

#### 2.0.3 🤦函数指针

```c
/*
* 时间：2020/10/19 9:03
* 功能：设计一个函数，这个函数可以通过参数中的函数指针值的不同分别调用三个子函数。
*/

#include <stdio.h>

typedef void (*Fuben)(int);  //定义一个函数指针类型Fuben,指针所指向的函数类型与子函数类型一致。
                             //void Fuben1(int x);
							//void Fuben2(int x);
							//void Fuben3(int x);
							//函数指针变量

void Fuben1(int x);
void Fuben2(int x);
void Fuben3(int x);

void CallFuben(Fuben fP, int x);//叫唤的函数，函数指针常量

int main(void)
{

	CallFuben(Fuben1, 20);
	CallFuben(Fuben2, 30);
	CallFuben(Fuben3, 40);

	return 0;
}

void CallFuben(Fuben fP, int x)
{
	fP(x);
	return;
}

void Fuben1(int x)
{
	printf_s("1: %d\n", x);
	return;
}

void Fuben2(int x)
{
	printf_s("2: %d\n", x);
	return;
}

void Fuben3(int x)
{
	printf_s("3: %d\n", x);
	return;
}



/*
* 结论：
* 
* 函数名其实质为一个指针，定义一个函数指针即为定义一个函数指针变量。
* 
* 例如：
* int Yuan(int x);//通常的把函数指针常量的*省略不写
* int (*Fuben)(int);//不可丢弃函数指针变量中的*！！！
* 
* 函数指针变量指向函数指针常量：
* 
* Fuben  = &Yuan;	或者	Fuben = Yuan;   //函数指针变量指向函数指针常量
* （*Fuben)(实参);	或者	Fuben(实参);	//调用函数指针变量
* 
* 注意：
* int Yuan(int x);不可写成int （*Yuan）(int x);
* int (*Fuben)(int);不可写成int Fuben(int);
*/
```



#### 2.0.4 获取数组元素大小

指向数组元素的指针相减

```c
/*
* 时间：2020.11.7
* 功能：通过数组指针，获得数组元素的个数。
*/
#include <stdio.h>
int main(void)
{
	int a[3] = { 1,2,3 };
	int* pa;
	int* pb;
	int c;
	//书写形式一：
	//pa = a;//pa指向数组第一个元素
	//pb = a + 3;//pb指向数组第三个元素
	//书写形式二：
	pa = &a[0];
	pb = &a[3];

	c = pb - pa;
	printf_s("a的首地址为%d\na的首个溢出地址为%d\n", pa, pb);
	printf_s("a的元素个数为%d\n", c);
	return 0;
}
/*
* 运行结果：
a的首地址为19922536
a的首个溢出地址为19922548
a的元素个数为3

结论：
	指向数组的指针，两者相减是以数组指针类型的运算，不是两个指针地址数值上面的算术运算。
    例如，pa, pb指针是int*类型，他们相加减是 
*/
```









### 2.1 数组

#### 2.1.1  动态分配二维数组

```C
/*
时间：2020.11.23/19：26
功能：动态分配二位数组,四行二列
*/
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
int main (void)
{
    int i, j, k;
    int **a = (int**)malloc(sizeof(int*) * 4);
    if(NULL == a)
    {
        printf("内存分配失败！\n");
    }
    for(i = 0; i < 4; i++)
    {
        a[i] = (int*) malloc(sizeof(int) * 2);
        if (NULL == a[i])
        {
            printf("内存分配失败！\n");
        }
    }
    for (i = 0; i < 4; i++)
    {
        a[i][0] = 0;
        a[i][1] = 1;
    }
    for(i = 0; i < 4; i++)
    {
        printf("%d %d\n", a[i][0], a[i][1]);
    }
   return 0;
}
```





### 2.2 实数变量

#### 2.2.1 浮点型 X = 0？

浮点型数据在内存中不是准确的存储的，例如：float x = 2,也许在内存中是1.999999.

```c
/*
* 时间：	2020/10/13 21:40
* 功能：	判断浮点型 x = 0，是否为0.
*/
#include <stdio.h>
int main(void)
{
	float x = 0;
	
	if( x <= 0.000001 && x >=0.000001 )
	{
		printf_s("x是0！\n");
	}
	else
	{
		printf_s("x不是0！\n");
	}
	return 0;
}


/*
* 结论：
*		if( |x-0.000001| < 0 )
*					yes;
*		else
*                    no;
*/
```

### 2.3 🔴递归

```c
/*
* 时间：2020/10/15 20:52
* 功能：递归实现1+2+3+4+...+100
*/
#include <stdio.h>

int accumulation(int n);
int main(void)
{
	int i = 100;
	int sum;
	sum  = accumulation(i);
	printf_s("%d", sum);

	return 0;
}

int accumulation(int n)
{
	int add = 0;
	
	if ( n == 0 )
	{
		return add;
	}
	else
	{
		add = n + accumulation(n - 1);
	}
}
```







## <三> 小技巧

### 2.1 交换俩个数字

1.1	核心知识点：

异或：A异或偶数个B任然等于本身A；

​			A异或奇数和个1任然等于本身A；

​           A异或奇数和个0任然等于A的相反数。

1.2 	优点：

无需定义交换时的中间变量。

1.2 	代码实现：

```c
#include <stdio.h>
int main (void)
{
    int a = 3;
    int b = 4;
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
```

###  2.2 判断回文数

```c
#include <stdio.h>
int main(void)
{
	int val; //存放待判断的数字
	int m;
	int sum = 0;

	printf("请输入您需要判断的数字:  ");
	scanf_s("%d", &val);

	m = val;
	while (m)
	{
              sum = sum * 10 + m % 10;
	    m /= 10;
	}

	if (sum == val)
			printf_s("Yes!\n");
	else
			printf_s("No!\n");

	return 0;
}
```

### 2.3判断素数

```c
/*
* 时间：2020/10/17 12:14
* 功能：判断指定数据域中的素数并输出。
*/

#include <stdio.h>
#include <stdbool.h>

bool IsPrime(int val);
void OutPrime(int number);

int main(void)
{
	int i = 100;

	OutPrime(i);

	return 0;
}

bool IsPrime(int val)
{
	int i;

	for (i = 2; i < val; i++)
	{
		if (0 == val % i)
		{
			break;
		}
	}
	if (i == val)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void OutPrime(int number)
{
	int i;
	for (i = 0; i < number; i++)
	{
		if (IsPrime(i))
		{
			printf_s("%d\n", i);
		}

	}
	return;
}


/*
* 结论：
* ------------------------------------------------------------
* 素数：只有1和自己本身可以整除的整数。
* 将大模块功能分成小模块功能，拼接小模块实现大模块的功能实现。
* -------------------------------------------------------------
*/

```



