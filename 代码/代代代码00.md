# 👣这是呵呵好吧吃不好的

---

## <一> 基本呀，别忘了

#### 1.1 enum枚举

```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{

    enum color 
    { 
        red = 1, green, blue 
    };//若设置red=1,那么gree=2,blue=3。

    enum  color favorite_color;

    /* 用户输入数字来选择颜色 */
    printf_s("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf_s("%u", &favorite_color);

    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }
  return 0;
}
```

#### 1.2 格式输出

```c
#include <stdio.h>

int main(void)
{
	printf_s("%5d\n%5.3d\n%05d\n%05.3d\n", 6, 6, 6, 6);
	return 0;
}

/*
* 运行结果：
* ------------------
	6  -----------%5d
  006-----------%5.3d
00006-----------%05d
  006-----------%05.3d
  ------------------

*/
```

#### 1.3 格式输入

##### 1.3.1 scanf("%c",&ch)与scanf(" %c",&ch)

```c
#include <stdio.h>
int main(void)
{
	char ch;
	scanf_s(" %c", &ch);
	printf_s("%c", ch);
	

#if 0
	int i;
	scanf_s("%d", &i);
	printf_s("%d", i);
#endif

	return 0;
}

/*
* 结论：
* -----------------------------------------------------------------------------------------
* 1，scanf等待它所需要的一个数据类型，读取到匹配类型后，将其保存至缓冲区中，遇到空白自动跳过。但%c类型除外。
*			scanf("%d%d",&a,&b);   <==>   scanf("%d  %d",&a,&b);
* 
* 2，scanf("%c",&ch);从输入中的第一个字符开始读取，scanf(" %c",&ch);则从第一个非空白字符开始读取。
对于%d输入的无影响。
* -----------------------------------------------------------------------------------------
*/
```

#### 1.4 转义字符

```c
/*
* 时间：2020/10/17 22:51
* 
* 活跃位置就是屏幕光标位置
* 
* 转义序列字符不一定在所有的显示设备上都起作用。
* 
* 使用 转义字符 较 ASCII码 好，提高可移植性。 
*/
#include <stdio.h>

int main(void)
{
	//功能：
	//printf_s("报警\\a： \a");
	//printf_s("退格\\b： \b");
	//printf_s("换页\\f： \f");
	//printf_s("换行\\n： \n");
	//printf_s("回车： \r");
	//printf_s("水平制表符：\t");

	//， “   ‘     /     显示
	//printf_s("反斜杠：\\");
	//printf_s("单引号：\'");
	//printf_s("双引号：\"");
	//printf_s("问号：\?");

	//进制
	//printf_s("八进制：\077");
	//printf_s("十六进制：\xFF");

	return 0;
}
```

#### 1.5  字符串的输入输出

```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    //输出：
    //1.字符串数组，初始化
    char s1[] = "arry";//末尾自动补'\0'
    char s2[6] = "arry";
    printf("字符串数组：%s %c",s1,s2[2]);

    //2.字符串指针，初始化
    char *sp = "pointer";
    printf("字符串指针：%s, %c %c\n", sp, *sp, *(sp+2));

    3.数组，scanf
    char s1[6];//允许无限写入
    scanf("%s", s1);
    printf("%s\n", s1, s1[2]);

    //4.指针，scanf
    char *sp;//只是声明了一个指针变量，并没有为此分配内存空间
    sp = (char*) malloc(sizeof(char)*1);
    if (NULL ==sp)
    {
        printf("内存分配失败！\n");
        exit(-1);
    }
    scanf("%s", sp);
    printf("%s %c\n", sp, *sp);

    //5.指针，数组，scanf
    char str[60],*sp = str;
    scanf("%s", str);
    printf("%s %c %c\n", str, str[1], str[3]);
    printf("%s %c %c\n", sp, *(sp+1), *(sp+3));

    //6.🔴如下运行会终止
    char *sp;
    scanf("%s", sp);
    printf("%s %c %c\n", sp, *(sp+1), *(sp+4));

    //7.scanf和gets
    char str1[60], str2[60];
    gets(str1);//将接收输入的整个字符串直到遇到换行符为止
    printf("%s",str1);
    scanf("%s", str2);//如果输入了空格会认为字符串结束，空格和的字符将作为下一个输入项处理
     printf("%s",str1);

    return 0;
}
```

```c
#include <stdio.h>

int main (void)
{
    char *s[]={"man","woman","girl","boy","sister"};
    char **q;
    int k;
    
    for(k=0;k<5;k++)
    { 
        *q = s[1];
        printf("%s\n",*q); 
    }

 return 0;
}
```



### 1.5 getchar 和putchar

#### 1.5.1 基本

```c
#include <stdio.h>
int main(void)
{
	char ch;
//用法一
#if 0
	ch = getchar();
	putchar(ch);
#endif

//用法二
//#if 0
	while (ch = getchar() != '#')//   #为一个输入结束标志
		putchar(ch);
//	return 0;
}

/*
* 运行结果：
* -------------------
* 用法一：
* sdfg
*  s
* 用法二：
* 
* --------------------
* 结论：
* 1，
* getchar 和 putchar 每次只处理一个字符！！！
* 使用while循环可以实现输入字符串，并显示到终端中。
* 2，
* getchar 和 putchar可以处理空格，换行符，Tab等，而scanf,printf不可处理这些字符。
*/
```

#### 1.5.2 getchar()读取文件

```c
#include <stdio.h>

int main(void)
{
	int ch;
	while (ch = getchar() != EOF)
		putchar(ch);
	return 0;
}
/*
* 运行结果：
* ------------------
* ctrl + C ==> EOF
* -----------------
* 结论：
* -----------------
* EOF标志文件结束
* -----------------
*/
```

#### 1.5.3  应用

##### 1.5.3.1 输入指定的一个字符，打印指定A行指定B列

```c
/*时间：2020/10/21 20:15*/
#include <stdio.h>
#include <stdbool.h>

void display(char ch, int a, int b);

int main(void)
{
	int ch;
	int rows, cols;
	printf_s("请您输入一个待打印的字符 ,定制打印的行数列数ch， rows， cols\n");

	while ((ch = getchar()) != '\n')
	{
		if (scanf_s("%d %d", &rows, &cols) != 2)
		{
			printf_s("您输入的行列为非法！\n");
			break;
		 }
		display(ch, rows, cols);
		while (getchar() != '\n')
		      continue;
		printf_s("请您输入一个待打印的字符 ,定制打印的行数列数ch， rows， cols\n");
		
	}
	printf_s("程序退出！\n");
	

	return 0;
}

void display(char ch, int a, int b)
{
	int i, j;
	for (i = 0; i < a; i++)
	{
		for (j = 0; j < b; j++)
			putchar(ch);
		putchar('\n');
	}
	return;
}
/*
* 运行结果：
* -------------------------------------------------------------------
请您输入一个待打印的字符 ,定制打印的行数列数ch， rows， cols
c 3 2
cc
cc
cc
请您输入一个待打印的字符 ,定制打印的行数列数ch， rows， cols
d 4 5
ddddd
ddddd
ddddd
ddddd
请您输入一个待打印的字符 ,定制打印的行数列数ch， rows， cols
a 3 r
您输入的行列为非法！
程序退出！
------------------------------------------------------------------
*/
```



##### 1.5.3.2 计算特定范围所有整数的平方和

```c
/*
* 时间：2020/10/21 18:57
* 功能：计算特定范围所有整数的平方和。程序限制了范围，上限是10000000，下限是-10000000
* 注意：人机交互，注意用户输入的非法数据的处理
*/
#include <stdio.h>
#include <stdbool.h>

bool bad_limits(long begin, long end, long low, long high);
unsigned long long sum_squares(long a, long b);
long get_int(void);

int main(void)
{
	const long MIN = -10000000;
	const long MAX = 10000000;
	long start;
	long stop;
	double answer;

	printf_s("该程序是计算指定范围内所有整数的平方和\n"
		     "该程序限制了范围，上限是10000000，下限是-10000000\n"
		     "请输入您要计算的整数范围，上限start = ,下限stop = :(start = 0，stop = 0时，退出程序)\n");
	start = get_int();
	stop = get_int();
	
	while (start != 0 || stop != 0)
	{
		if (bad_limits(start, stop, MIN, MAX))
			printf_s("您输入的start与stop不在上下限内,\n"
				"请输入-10000000到10000000内的数字，并且保证strat大于stop.\n");
		else
		{
			answer = sum_squares(start,stop);
				printf_s("从%ld到%ld之间的平方和为%ld.\n",start,stop,answer);
		}
		printf_s("程序限制了范围，上限是10000000，下限是 - 10000000\n"
			     "请输入您要计算的整数范围，上限start = ,下限stop = :(start = 0，stop = 0时，退出程序)\n");
		start = get_int();
		stop = get_int();

	}
	printf_s("您成功退出该程序！\n");
	
	return 0;
}

long get_int(void)
{
	long input;
	char ch;
	while (scanf_s("%ld", &input) != 1)//判断输入是否合法
	{
		while((ch = getchar()) != '\n')//将输入错误的字符数字显示出来。
		putchar(ch);
		printf_s("\n输入失败！\n请您输入-10000000到10000000之间的数值。\n");
	}
	return input;
}

bool bad_limits(long begin, long end, long low, long high)
{
	if ((low < begin) && (begin < end) && (end < high))
	{
		return false;
	}
	else
	{
		return true;
	}

}

unsigned long long sum_squares(long a, long b)
{
	int i;
	unsigned long long sum = 0;
	for (i = a; i <= b; i++)
	{
		sum += i * i;
	}
	return sum;
}

/*
* 运行结果：
* ------------------------------------------------------------------------------------------
* 该程序是计算指定范围内所有整数的平方和
该程序限制了范围，上限是10000000，下限是-10000000
请输入您要计算的整数范围，上限start = ,下限stop = :(start = 0，stop = 0时，退出程序)
adhf fjgg
adhf fjgg
输入失败！
请您输入-10000000到10000000之间的数值。
4685 98
您输入的start与stop不在上下限内,
请输入-10000000到10000000内的数字，并且保证strat大于stop.
程序限制了范围，上限是10000000，下限是 - 10000000
请输入您要计算的整数范围，上限start = ,下限stop = :(start = 0，stop = 0时，退出程序)
1234 99999
从1234到99999之间的平方和为-1656629504.
程序限制了范围，上限是10000000，下限是 - 10000000
请输入您要计算的整数范围，上限start = ,下限stop = :(start = 0，stop = 0时，退出程序)
0 0
您成功退出该程序！
-----------------------------------------------------------------------------------------
结论：
知识点：

1，输入验证：
				while (scanf_s("%ld", &input) != 1)//判断输入是否合法
				{
		            while((ch = getchar()) != '\n')//将输入错误的字符数字显示出来。

		            putchar(ch);
				}

2，消除输入字符的空格和一些非法输入：
		         while(getchar() != '\n')  //当输入为非换行符时，跳出本次循环，
				      continue;            //输入是换行符时，则不执行，但换行符已经被执行了，不在作用于我们的功能语句
*/
```

##### 1.5.3.3  菜单给用户提供一份响应程序的选项

```c
/*
* 时间：2020/10/21 21:52
* 功能：菜单给用户提供一份响应程序的选项
*		a.advise		b.bell
*		c.count			q.quit
* 选项说明：
* a:输出buy low,sell high
* b:响铃
* c:计数
* q:退出
* 
* 自行定义四个选项的功能
*/

#include <stdio.h>
#include <stdbool.h>
char get_choice(void);//输入选择项。
char get_frist(void);//获取输入选择项的第一个字符

int get_int(void);//得到一个数

int main(void)
{
	char choice;
	while (((choice = get_choice()) != 'q'))
	{
		switch (choice)
		{
		case 'a': printf_s("aaaa\n"); break;
		case 'b':printf_s("\a"); break;
		case 'c':printf_s("ccccc\n"); break;
		default:printf_s("程序出错啦！\n"); break;

		}
	}
	printf_s("程序退出成功！\n");

	return 0;
}

int get_int(void)//此模块排除了非数值的非法输入
{
	char ch;
	int input;
	while (scanf_s("%d", &input) != 1)//scanf_s写入失败
	{
		while ((ch = getchar()) != '\n')//scanf_s写入失败的数据被getchar成功捕获。
			//continue;
			putchar(ch);
		printf_s("输入非法！\n");
		printf_s("请重新输入\n");
	}
	return input;
}
char get_frist(void)
{
	char ch;
	ch = getchar();
	while (getchar() != '\n') //注意此句的作用的消除掉缓冲区里面的字符
		continue;
	return ch;
}
char get_choice(void)
{
	char ch;
	printf_s("请输入您的选择：\n");
	printf_s("a.advice          b.bell\n");
	printf_s("c.count           c.quit\n");
	ch = get_frist();
	while ((ch < 'a' || ch > 'c') && ch != 'q')
	{
		printf_s("请您输入a.b.c.q中的任意一个选项.\n");
		ch = get_frist();
	}
	return ch;
}

/*
* 结论：
* 1，
* getchar()需要得到一个字符时使用。
* scanf_s()需要得到一个数值时使用。
* 2，
* getchar()得到一个字符时，我们需要考虑缓冲区中所存储的剩余字符。
* 
*	ch = getchar();
*	while ( getchar() != '\n')
*			continue;
* 
* 3，
* scanf_s得到一个合法的数值，需要我们排除非法的输入字符。
* 
	while (scanf_s("%d", &input) != 1)//scanf_s写入失败
	{
		while ((ch = getchar()) != '\n')//scanf_s写入失败的数据被getchar成功捕获。
			//continue;
			putchar(ch);
		printf_s("输入非法！\n");
		printf_s("请重新输入\n");
	}
}
* 
*/
```



### 1.6 全局变量，局部变量

#### 1.6.0 应用

#####  1.6.1产生随机数

```c
#include <stdio.h>
#include <time.h>
unsigned int rand(void);
void srand(unsigned int seed);

//全局变量next
static unsigned int next;

int main(void)
{

	int count;
	unsigned int seed;
	int strat;
	
	printf_s("请按下任意数字开启程序（按下非数字按键即结束程序）：\n");

	while (scanf_s("%d", &strat) == 1)
	{
		srand(time(0));
		printf_s("next = %d \n", next);
		for (count = 0; count < 5; count++)
		{
			printf_s("%d\n", rand());
		}
		printf_s("请按下任意数字开启程序（按下非数字按键即结束程序）：\n");
	}
	printf_s("程序退出！\n");
	return 0;
}
void srand(unsigned int seed)//更换一个种子
{
	extern next;
	next = seed;
}
unsigned int rand(void)//产生一个随机数
{
	extern next;
	next = next * 1129847695 + 12345;
	return (next / 65536) % 32768;
}



```



##### 1.6.2 扔色子

```c
/*
* 时间：2020/10/23 23:17
* 功能：投掷骰子，用户输入骰子的面数，和需要投掷几次，程序需要反馈给用户每次投掷的结果与投掷骰子结束后，结果的总和
*/

#include <stdio.h>
#include <time.h>
int get_sides(void);
int get_dice(void);
int rand(void);
void srand(unsigned int seed);
unsigned int next;
int main(void)
{
	int dice;//次数
	int sides;
	int i;
	int count;//每次的结果
	int sum = 0;//共计
	printf("请输入任意键进入投掷骰子的小游戏中......\n若要退出请按#号键哦！\n");
	while (getchar() != '#')
	{
		printf("您已经进入到扔掷骰子小游戏中啦......\a\n");
		printf("你投掷的骰子有几面呢？\n");
		sides = get_sides();
		printf("你需要投掷骰子几次呢？\n");
		dice = get_dice();
		srand(time(0));
		for (i = 0; i < dice; i++)
		{
			
			count = rand();
			printf("第%d次投掷骰子的结果为：%d\n", i + 1, count);
			sum += count;
		}

		printf("本次投掷结束！投掷的总和为%d\n", sum);
		while (getchar() != '\n')
		{
			continue;
		}
		printf("请输入任意键进入投掷骰子的小游戏中......\n若要退出请按#号键哦！\n");
	}

	printf("您成功退出了扔掷骰子的小游戏哦，拜拜！\a\n");
	
	return 0;
}

int get_sides(void)
{
	int sides;
	char ch;
	while (scanf("%d", &sides) != 1 || sides <= 2)
	{
		printf("您输入的面数是不合现实的！\n亲！\n再输入一次吧！\n");
		while (ch = getchar() != '\n')
		{
			putchar(ch);
			printf("\n以上是非法输入哦！\n");
			continue;
		}
		
	}
	printf("面数输入成功！\n");
	return sides;
}
int get_dice(void)
{
	int dice;
	char ch;
	while (scanf("%d", &dice) != 1 || dice < 0)
	{
		printf("您输入的投掷次数不合现实哦！\n请重新输入吧！\n");
		while (ch = getchar() != '\n')
		{
			putchar(ch);
			printf("\n以上是非法输入哦！\n");
			continue;
		}

	}
	printf("输入投掷次数成功！\n");
	return dice;
}
int rand(void)//产生一个0——6的随机数
{
	next = next * 948674586 + 12345;
	return (next / 65536) % 6;
}

void srand(unsigned int seed)
{
	next = seed;
}


/*
* 运行结果：
* ---------------------------------------------------------------
* 请输入任意键进入投掷骰子的小游戏中......
若要退出请按#号键哦！
4
您已经进入到扔掷骰子小游戏中啦......
你投掷的骰子有几面呢？
3
面数输入成功！
你需要投掷骰子几次呢？
6
输入投掷次数成功！
第1次投掷骰子的结果为：3
第2次投掷骰子的结果为：2
第3次投掷骰子的结果为：4
第4次投掷骰子的结果为：3
第5次投掷骰子的结果为：1
第6次投掷骰子的结果为：0
本次投掷结束！投掷的总和为13
请输入任意键进入投掷骰子的小游戏中......
若要退出请按#号键哦！
#
您成功退出了扔掷骰子的小游戏哦，拜拜！
-------------------------------------------------------------------------
总结：
1，
分模块的思想很重要，尽量的划分细小的模块，是程序更加容易维护，修改
2，
这里面的next是一个静态的全局变量，系统默认它为文件作用域，静态变量，初始值为0
3，
rand() 和 srand()， 前者产生随机数，后者产生种子，将两者分开的原因是，便于使用time(0)来产生种子

*/

```





### 1.7 文件的打开/创建，关闭，读取写入

#### 1.7.1 open（）

- 头文件：

  > \#include <sys/types.h>
  >
  > \#include <sys/stat.h>
  >
  > \#include <fcntl.h>

- 函数原型：int open(const char *pathname, int flags);

- 返回值： 

  >  成功 -> 返回新文件描述符
  >
  >  失败 -> 返回-1

- 形参：

  > const char *pathname:文件的路径和文件名字
  >
  >  int flags:文件打开方式标志位
  >
  >  							必须三选一： O_RDONLY //只读
  >
  > ​             											O_WRONLY //只写
  >
  > ​              											O_RDWR  //可读可写

​      还可以加附加的文件打开方式标志位：。。。。。

#### 1.7.2  close();

- 头文件：

  > #include <unistd.h>

- 函数原型：

  > int close(int fd);

- 返回值：

  > 成功 :0
  >
  >  失败 : -1

- 形参

  > int fd 一个已经打开的文件描述符



#### 1.7.3 open()和close()示例



>
>
>```c
>#include <stdio.h>
>#include <sys/types.h>
>#include <sys/stat.h>
>#include <fcntl.h>
>#include <unistd.h>
>int main(void)
>{
>    
>    int fd = open("1.txt",O_RDWR);
>    if (-1 == fd) perror("file open error");
>    else perror("file open ok");
>    //int fd = open("1.txt",O_RANDOM | O_CREAT);
>    char buff[12] = "";
>   int wret = write(fd,buff,12);
>   if (-1 = wret)perror("file write error");
>   else perror("file write ok");
>    int ret = close(fd);
>    if(-1 == ret) perror("file clse error");
>    else if(0 == ret) perror("file close ok");
>}
>
>/*
>运行结果：
>成功：
>file open ok: Invalid argument
>file close ok: Invalid argument
>失败：
>file open error: No such file or directory
>file clse error: Bad file descriptor
>*/
>
>```
>
>

#### 1.7.4 read()

- 头文件：

  >  #include <unistd.h>

- 函数原型：

  > size_t write(int fd, const void* buf, size_t count);

- 返回值：经过宏定义的一个整数

  > 成功：实际写入的字节数
  >
  > 失败：-1

- 形参：

  > int fd:一个已经打开了的文件描述符
  >
  > const void* buf:
  >
  > ​								void* buf:指针，通配型指针，可以指向任意类型的指针。表示指向要写入文件的内容。
  >
  > ​								size_t count:要写入的字节数

注意：

（1）写入的文件，将原有的文件覆盖，而不是在原文件之前插入写入。

（2）注意写入文件的字节数是你需要写入的字符长度，不要考虑结束标志'\0'，

==**文件是不存在结束符的！！！**==



#### 1.7.5 writ()











#### 1.7.5 read() 和 writ()示例





#### 1.7.6  文件IO总结

- 当read()读取目标字节大小大于真实函数读取的大小，read读取的字节数为真实函数读取的大小。
- 当write（）写入的目标字节大小真实函数读取的大小,write读取的字节数为目标字节大小。





#### 1.7.7 文件IO示例

复制1.txt的内容到2.txt中

> ```c
> #include <stdio.h>
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <fcntl.h>
> #include <unistd.h>
> int main(void)
> {
>     int wret;
>     int rret = 9;
>     int fd1 = open("1.txt",O_RDWR);
>     if (-1 == fd1) perror("file1 open error");
>     else perror("file1 open ok");
>     char buff[26] = "zww can study C very good!";
>      int fd2 = open("2.txt",O_RDWR);
>     if (-1 == fd2) perror("file2 open error");
>     else perror("file2 open ok");
>     //读
>     char num[2];
>     while(rret != 0)
>     {
>          rret = read(fd1,num,2);
>         if (-1 == rret) perror("file1 read 1 error");
>         else 
>         {
>              perror("file1 reed 1 ok");
>              //写
>              wret = write(fd2,num,1);
>           if (-1 == wret)perror("file2 write error");
>         else perror("file2 write ok");
>         }
>    }
> 
>  //关闭文件
>     int cret = close(fd1);
>     if(-1 == cret) perror("file1 clse error");
>     else if(0 == cret) perror("file1 close ok");
>       cret = close(fd2);
>     if(-1 == cret) perror("file2 clse error");
>     else if(0 == cret) perror("file2 close ok");
> }
> ```
>
> 



## <二>	运用吧

### 2.0🔴指针

#### 2.0.1  改变常量的内存单元地址

```c
#include <stdio.h>
void fun(int**);
int main(void)
{
	int i;
	int* p;
	//p = &i;
	printf_s("%p\n", p);
	//fun(&p);
	fun(&i);
	printf_s("%p\n", p);
	return 0;
}
void fun(int** q)//传入地址的地址，变量的地址是你要当成变量所要更改的内容
{
	*q = (int*)0xffffffff;
	return;
}
```

#### 2.0.2 动态内存跨函数分配

在子函数中动态分配数组空间，不会将子函数中的数组释放。

```c
#include <stdio.h>
#include <malloc.h>
int* MallocAddress(void);
int main(void)
{
	int* a;
	a = MallocAddress();
	printf_s("%d, %d, %d, %d",a[0],a[1],a[2],a[3]);
	free(a);
	a = NULL;
	return 0;
}

int* MallocAddress(void)//P数组空间不会被释放
{
	int* p = (int*)malloc(sizeof(int) * 4);
	p[0] = 1;
	p[1] = 2;
	p[2] = 3;
	p[3] = 4;

	return p;
 }
```

#### 2.0.3 🤦函数指针

```c
/*
* 时间：2020/10/19 9:03
* 功能：设计一个函数，这个函数可以通过参数中的函数指针值的不同分别调用三个子函数。
*/

#include <stdio.h>

typedef void (*Fuben)(int);  //定义一个函数指针类型Fuben,指针所指向的函数类型与子函数类型一致。
                             //void Fuben1(int x);
							//void Fuben2(int x);
							//void Fuben3(int x);
							//函数指针变量

void Fuben1(int x);
void Fuben2(int x);
void Fuben3(int x);

void CallFuben(Fuben fP, int x);//叫唤的函数，函数指针常量

int main(void)
{

	CallFuben(Fuben1, 20);
	CallFuben(Fuben2, 30);
	CallFuben(Fuben3, 40);

	return 0;
}

void CallFuben(Fuben fP, int x)
{
	fP(x);
	return;
}

void Fuben1(int x)
{
	printf_s("1: %d\n", x);
	return;
}

void Fuben2(int x)
{
	printf_s("2: %d\n", x);
	return;
}

void Fuben3(int x)
{
	printf_s("3: %d\n", x);
	return;
}



/*
* 结论：
* 
* 函数名其实质为一个指针，定义一个函数指针即为定义一个函数指针变量。
* 
* 例如：
* int Yuan(int x);//通常的把函数指针常量的*省略不写
* int (*Fuben)(int);//不可丢弃函数指针变量中的*！！！
* 
* 函数指针变量指向函数指针常量：
* 
* Fuben  = &Yuan;	或者	Fuben = Yuan;   //函数指针变量指向函数指针常量
* （*Fuben)(实参);	或者	Fuben(实参);	//调用函数指针变量
* 
* 注意：
* int Yuan(int x);不可写成int （*Yuan）(int x);
* int (*Fuben)(int);不可写成int Fuben(int);
*/
```



#### 2.0.4 获取数组元素大小

指向数组元素的指针相减

```c
/*
* 时间：2020.11.7
* 功能：通过数组指针，获得数组元素的个数。
*/
#include <stdio.h>
int main(void)
{
	int a[3] = { 1,2,3 };
	int* pa;
	int* pb;
	int c;
	//书写形式一：
	//pa = a;//pa指向数组第一个元素
	//pb = a + 3;//pb指向数组第三个元素
	//书写形式二：
	pa = &a[0];
	pb = &a[3];

	c = pb - pa;
	printf_s("a的首地址为%d\na的首个溢出地址为%d\n", pa, pb);
	printf_s("a的元素个数为%d\n", c);
	return 0;
}
/*
* 运行结果：
a的首地址为19922536
a的首个溢出地址为19922548
a的元素个数为3

结论：
	指向数组的指针，两者相减是以数组指针类型的运算，不是两个指针地址数值上面的算术运算。
    例如，pa, pb指针是int*类型，他们相加减是 
*/
```









### 2.1 数组

#### 2.1.1  动态分配二维数组

```C
/*
时间：2020.11.23/19：26
功能：动态分配二位数组,四行二列
*/
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
int main (void)
{
    int i, j, k;
    int **a = (int**)malloc(sizeof(int*) * 4);
    if(NULL == a)
    {
        printf("内存分配失败！\n");
    }
    for(i = 0; i < 4; i++)
    {
        a[i] = (int*) malloc(sizeof(int) * 2);
        if (NULL == a[i])
        {
            printf("内存分配失败！\n");
        }
    }
    for (i = 0; i < 4; i++)
    {
        a[i][0] = 0;
        a[i][1] = 1;
    }
    for(i = 0; i < 4; i++)
    {
        printf("%d %d\n", a[i][0], a[i][1]);
    }
   return 0;
}
```





### 2.2 实数变量

#### 2.2.1 浮点型 X = 0？

浮点型数据在内存中不是准确的存储的，例如：float x = 2,也许在内存中是1.999999.

```c
/*
* 时间：	2020/10/13 21:40
* 功能：	判断浮点型 x = 0，是否为0.
*/
#include <stdio.h>
int main(void)
{
	float x = 0;
	
	if( x <= 0.000001 && x >=0.000001 )
	{
		printf_s("x是0！\n");
	}
	else
	{
		printf_s("x不是0！\n");
	}
	return 0;
}


/*
* 结论：
*		if( |x-0.000001| < 0 )
*					yes;
*		else
*                    no;
*/
```

### 2.3 🔴递归

```c
/*
* 时间：2020/10/15 20:52
* 功能：递归实现1+2+3+4+...+100
*/
#include <stdio.h>

int accumulation(int n);
int main(void)
{
	int i = 100;
	int sum;
	sum  = accumulation(i);
	printf_s("%d", sum);

	return 0;
}

int accumulation(int n)
{
	int add = 0;
	
	if ( n == 0 )
	{
		return add;
	}
	else
	{
		add = n + accumulation(n - 1);
	}
}
```







## <三> 小技巧

### 2.1 交换俩个数字

1.1	核心知识点：

异或：A异或偶数个B任然等于本身A；

​			A异或奇数和个1任然等于本身A；

​           A异或奇数和个0任然等于A的相反数。

1.2 	优点：

无需定义交换时的中间变量。

1.2 	代码实现：

```c
#include <stdio.h>
int main (void)
{
    int a = 3;
    int b = 4;
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
```

###  2.2 判断回文数

```c
#include <stdio.h>
int main(void)
{
	int val; //存放待判断的数字
	int m;
	int sum = 0;

	printf("请输入您需要判断的数字:  ");
	scanf_s("%d", &val);

	m = val;
	while (m)
	{
              sum = sum * 10 + m % 10;
	    m /= 10;
	}

	if (sum == val)
			printf_s("Yes!\n");
	else
			printf_s("No!\n");

	return 0;
}
```

### 2.3判断素数

```c
/*
* 时间：2020/10/17 12:14
* 功能：判断指定数据域中的素数并输出。
*/

#include <stdio.h>
#include <stdbool.h>

bool IsPrime(int val);
void OutPrime(int number);

int main(void)
{
	int i = 100;

	OutPrime(i);

	return 0;
}

bool IsPrime(int val)
{
	int i;

	for (i = 2; i < val; i++)
	{
		if (0 == val % i)
		{
			break;
		}
	}
	if (i == val)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void OutPrime(int number)
{
	int i;
	for (i = 0; i < number; i++)
	{
		if (IsPrime(i))
		{
			printf_s("%d\n", i);
		}

	}
	return;
}


/*
* 结论：
* ------------------------------------------------------------
* 素数：只有1和自己本身可以整除的整数。
* 将大模块功能分成小模块功能，拼接小模块实现大模块的功能实现。
* -------------------------------------------------------------
*/

```



